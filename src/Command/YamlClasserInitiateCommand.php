<?php

namespace Achinon\YamlClasserBundle\Command;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Console\Attribute\AsCommand;
use Achinon\YamlClasserBundle\Generator;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Yaml\Yaml;
use Symfony\Component\Filesystem\Exception\IOExceptionInterface;
use Exception;
use Achinon\ToolSet\Parser;
use Symfony\Component\Filesystem\Exception\FileNotFoundException;

#[AsCommand(name: 'achinon:yaml_classer', description: 'Generates PHP Class file based on your YAML config file.')]
class YamlClasserInitiateCommand extends Command
{
    private Filesystem $filesystem;
    private ?SymfonyStyle $io = null;
    private string $checksum_file;
    private ?string $checksum_value = null;

    public function __construct()
    {
        parent::__construct();
        $this->filesystem = new Filesystem();
        $this->checksum_file = __DIR__.'/../config_checksum.yml';
    }

    protected function configure()
    {
        $this->addArgument('yaml_file_path', InputArgument::REQUIRED, 'The YAML file to be generated.')
             ->addArgument('class_name', InputArgument::REQUIRED, 'Class you wish to call to access this yaml file.');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $file = $input->getArgument('yaml_file_path');
        $base_class_name = $input->getArgument('class_name');

        $this->io = $io = new SymfonyStyle($input, $output);
        $io->title("Generating YAML configuration for file: $file");

        try {
            $success = static::generate($file, $base_class_name);
        }
        catch(Exception $e) {
            $io->error($e->getMessage());
            return Command::FAILURE;
        }

        switch($success){
            case true:
                $io->success(sprintf("File generated. You can now access your config through the class %s in your project.", $base_class_name));
                break;
            case false:
                $io->success("No change found. Skipping generation.");
                break;
        }

        return Command::SUCCESS;
    }

    /**
     * @throws Exception
     */
    protected function generate(string $yaml_file, string $base_class_name): int
    {
        $io = $this->io;

        $io->info('Checking if provided YAML file exists...');
        if(!$this->filesystem->exists($yaml_file)) {
            throw new Exception('YAML file does not exist!');
        }
        $io->info('Reading YAML contents and comparing with existing class.');

        $contents = file_get_contents($yaml_file);
        $io->info('Checking for changes.');
        $this->checkChecksumChange($contents, $base_class_name);
        if(is_null($this->checksum_value)) {
            return false;
        }

        $data = Yaml::parse($contents);

        $io->info('Generating classes.');
        $generatedCodeInPHP = $this->createTree($data, $base_class_name);

        $io->info('Saving classes to file.');
        $this->createClassFile($base_class_name, $generatedCodeInPHP);

        $io->info('Saving new checksum.');
        $this->saveChecksum($base_class_name);

        $io->info('Registering new class as service.');
        $this->addToServices("Achinon\\YamlClasserBundle\\$base_class_name");

        return true;
    }

    private function createClassFile(string $base_class_name, string $content)
    {
        $autogeneratedFileName = __DIR__."/../$base_class_name.php";
        $this->fileCreateIfNotExists($autogeneratedFileName);

        $namespace = "Achinon\\YamlClasserBundle";
        $introCode = '<?php'.PHP_EOL."namespace $namespace;".PHP_EOL;

        $this->filesystem->dumpFile($autogeneratedFileName, $introCode.$content);
    }

    /**
     * @throws Exception
     */
    private function saveChecksum(string $base_class_name)
    {
          $this->checksum_value ?? throw new Exception('Cannot save checksum if new value is uninitialised.');
        $contents = Yaml::parseFile($this->checksum_file);
        $contents[$base_class_name] = $this->checksum_value;
        $this->filesystem->dumpFile($this->checksum_file, Yaml::dump($contents));
    }

    /**
     * @throws Exception
     */
    private function checkChecksumChange(string $content, string $base_class_name): void
    {
        $this->fileCreateIfNotExists($this->checksum_file);
        $contents = Yaml::parseFile($this->checksum_file);

        $oldChecksum = $contents[$base_class_name] ?? '';
        $newChecksum = md5($content);

        if($newChecksum === $oldChecksum){
            return;
        }
        $this->checksum_value = $newChecksum;
    }

    /**
     * @throws Exception
     */
    private function fileCreateIfNotExists(string $filePath): void
    {
        if(!$this->filesystem->exists($filePath)) {
            try {
                $this->filesystem->touch($filePath);
            }
            catch(IOExceptionInterface $exception) {
                throw new Exception(sprintf('An error occurred while creating the file at %s', $exception->getPath()));
            }
        }
    }

    private function addToServices(string $FQCN)
    {
        $serviceFileLocation = __DIR__."/../services.yml";
        $filesystem = $this->filesystem;

        if (!$filesystem->exists($serviceFileLocation)) {
            throw new FileNotFoundException('Service file not found!');
        }

        $existing_services = $new_services = Yaml::parseFile($serviceFileLocation);

        if(isset($existing_services['services'][$FQCN])) {
            return;
        }

        $new_services['services'] = array_merge($existing_services['services'], [$FQCN => ['autowire' => true]]);

        $filesystem->dumpFile($serviceFileLocation, Yaml::dump($new_services, 4));
    }

    private static function createTree(iterable $a,
                                       string   $classPath): string
    {
        $classData = [];
        $subTreeCode = [];
        foreach($a as $b => $c) {
            if(!in_array(gettype($c), ['array', 'object'])) {
                if(is_numeric($b)) {
                    $b = Parser::strStrip($c);
                }

                $classData[$b] = static::definePropertyString(
                  $b, 'string', '"'.$c.'"'
                );
                continue;
            }

            do {
                $subTreeClassPath = \Achinon\ToolSet\Generator::randomAlphanumericString();
            } while (ctype_digit($subTreeClassPath[0]));

            $subTreeCode[$subTreeClassPath] = static::createTree($c, $subTreeClassPath);

            $classData[] = static::definePropertyString(
              $b,
              $subTreeClassPath,
              "new $subTreeClassPath()"
            );
        }

        $properties = $defines = [];
        foreach($classData as $data) {
            $properties[] = $data['property'];
            $defines[] = $data['define'];
        }

        $properties = Parser::arrayToString($properties, PHP_EOL);
        $defines = Parser::arrayToString($defines, PHP_EOL);
        $treeClassString = static::createClassString($classPath);

        Parser::replaceSubstringsInString([
          '__PROPERTIES__' => $properties,
          '__DEFINES__' => $defines
        ], $treeClassString);

        $codeFullPack = Parser::arrayToString($subTreeCode, '');

        return $treeClassString.' '.$codeFullPack;
    }

    private static function definePropertyString(string $name,
                                                 string $type,
                                                 string $equals = ''): array
    {
        $propertyName = Parser::stripSpecialCharacters($name);
        $prop = <<<PROPERTY
/** @var $type */
public $$propertyName;
PROPERTY;
        $dis = '$this';
        $define = <<<DEFINE
$dis->$propertyName = $equals;
DEFINE;

        return [
          'property' => $prop,
          'define' => $define
        ];
    }

    private static function createClassString($className)
    {
        return <<<CLASS_OPEN
class $className {
    __PROPERTIES__
    public function __construct()
    {
        __DEFINES__
    }
}
CLASS_OPEN;
    }
}