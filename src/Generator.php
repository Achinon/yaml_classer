<?php

namespace Achinon\YamlClasser;

use Exception;
use Symfony\Component\Yaml\Yaml;
use Achinon\ToolSet\Parser;

class Generator
{
    /** @throws Exception */
    public static function initiate(string $yaml_file): void
    {
        if(!file_exists($yaml_file)) {
            throw new Exception('YAML file does not exist!');
        }

        $contents = file_get_contents($yaml_file);

        //check checksum whether files need generating
        $checksumFileName = __DIR__.'/../config.checksum';
        static::fileCreateIfNotExists($checksumFileName);
        //check if new config file needs to be generated
        $checksumData = file_get_contents($checksumFileName);
        $oldChecksum = $checksumData;
        $checksum = md5($contents);
        if($oldChecksum == $checksum) {
            return;
        } //config file doesnt need generating

        $data = Yaml::parse($contents);

        $autogenerated_filename = "YamlConfig";
        //generating config file
        $generatedCodeInPHP = static::createTree($data, $autogenerated_filename);

        $autogeneratedFileName = __DIR__."/$autogenerated_filename.php";
        $namespace = __NAMESPACE__;
        $introCode = '<?php'.PHP_EOL."namespace $namespace;".PHP_EOL;
        static::fileCreateIfNotExists($autogeneratedFileName);

        file_put_contents($autogeneratedFileName, $introCode.$generatedCodeInPHP);
        file_put_contents($checksumFileName, $checksum);
    }

    private static function fileCreateIfNotExists(string $filePath): void
    {
        $folderPath = dirname($filePath);

        if(!file_exists($folderPath)) {
            mkdir($folderPath, 0755, true);
        }

        if(!file_exists($filePath)) {
            touch($filePath);
            chmod($filePath, 0644);
        }
    }

    private static function createTree(iterable $a,
                                       string   $classPath): string
    {
        $classData = [];
        $subTreeCode = [];
        $first = true;
        foreach($a as $b => $c) {
            if(!in_array(gettype($c), ['array', 'object'])) {
                if(is_numeric($b)) {
                    $b = Parser::strStrip($c);
                }

                $classData[$b] = static::definePropertyString(
                  $b, 'string', '"'.$c.'"'
                );
                continue;
            }
            $subTreeClassPath = $classPath;
            if($first){
                do {
                    $subTreeClassPath = \Achinon\ToolSet\Generator::randomAlphanumericString();
                } while (ctype_digit($subTreeClassPath[0]));
                $first = false;
            }

            $subTreeCode[$subTreeClassPath] = static::createTree($c, $subTreeClassPath);

            $classData[] = static::definePropertyString(
              $b,
              $subTreeClassPath,
              "new $subTreeClassPath()"
            );
        }

        $properties = $defines = [];
        foreach($classData as $data) {
            $properties[] = $data['property'];
            $defines[] = $data['define'];
        }

        $properties = Parser::arrayToString($properties, PHP_EOL);
        $defines = Parser::arrayToString($defines, PHP_EOL);
        $treeClassString = static::createClassString($classPath);

        Parser::replaceSubstringsInString([
          '__PROPERTIES__' => $properties,
          '__DEFINES__' => $defines
        ], $treeClassString);

        $codeFullPack = Parser::arrayToString($subTreeCode, '');

        return $treeClassString.' '.$codeFullPack;
    }

    private static function definePropertyString(string $name,
                                                 string $type,
                                                 string $equals = ''): array
    {
        $prop = <<<PROPERTY
/** @var $type */
public $$name;
PROPERTY;
        $dis = '$this';
        $define = <<<DEFINE
$dis->$name = $equals;
DEFINE;

        return [
          'property' => $prop,
          'define' => $define
        ];
    }

    private static function createClassString($className)
    {
        return <<<CLASS_OPEN
class $className {
    __PROPERTIES__
    public function __construct()
    {
        __DEFINES__
    }
}
CLASS_OPEN;
    }
}
